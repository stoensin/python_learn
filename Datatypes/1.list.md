# 列表

字符串和元组是不可变的，而列表是可变（mutable）的，可以对它进行随意修改。
字符串和元组转换成一个列表，只需使用 `list` 函数。

# Python列表操作误区 #
- [python基础:赋值、浅拷贝与深拷贝（关于list复制的误区）](http://www.cnblogs.com/yizhenfeng168/p/6911477.html)
1. 赋值

**赋值操作（包括对象作为参数、返回值）不会开辟新的内存空间，它只是复制了新对象的引用。**
```
 在python中，对象的赋值就是简单的对象引用，这点和C++不同。如下：
 list_a = [1,2,3,"hello",["python","C++"]]
 list_b = list_a
 这种情况下，list_b和list_a是一样的，他们指向同一片内存，list_b不过是list_a的别名，是引用。
 我们可以使用 list_b is list_a 来判断，返回true，表明他们地址相同，内容相同。也可使用id(x) for x in list_a, list_b 来查看两个list的地址。
 赋值操作（包括对象作为参数、返回值）不会开辟新的内存空间，它只是复制了新对象的引用。也就是说，除了list_b这个名字以外，没有其它的内存开销。
 修改了list_a，就影响了list_b；同理，修改了list_b就影响了list_a。
```

2. 浅拷贝（shallow copy）

**浅拷贝会创建新对象，其内容是原对象的引用。**

**浅拷贝之所以称为浅拷贝，是它仅仅只拷贝了一层**
```
 浅拷贝有三种形式：切片操作，工厂函数，copy模块中的copy函数
 比如对上述list_a，        
 切片操作：list_b = list_a[:]   或者 list_b = [each for each in list_a]
 工厂函数：list_b = list(list_a)
 copy函数：list_b = copy.copy(list_a)
 浅拷贝产生的list_b不再是list_a了，使用is可以发现他们不是同一个对象，使用id查看，发现它们也不指向同一片内存。
 但是当我们使用 id(x) for x in list_a 和 id(x) for x in list_b 时，可以看到二者包含的元素的地址是相同的。
 在这种情况下，list_a和list_b是不同的对象，修改list_b理论上不会影响list_a。比如list_b.append([4,5])。
 但是要注意，浅拷贝之所以称为浅拷贝，是它仅仅只拷贝了一层，在list_a中有一个嵌套的list，如果我们修改了它，情况就不一样了。
 list_a[4].append("C")。查看list_b，你将发现list_b也发生了变化。这是因为，你修改了嵌套的list。
 修改外层元素，会修改它的引用，让它们指向别的位置，修改嵌套列表中的元素，列表的地址并为发生变化，指向的都是同一个位置。
```

3. 深拷贝（deep copy）

**和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因而，它的时间和空间开销要高。**
```
 深拷贝只有一种形式，copy模块中的deepcopy函数。
 和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因而，它的时间和空间开销要高。
 同样对list_a，若使用list_b = copy.deepcopy(list_a)，再修改list_b将不会影响到list_a了。
 即使嵌套的列表具有更深的层次，也不会产生任何影响，因为深拷贝出来的对象根本就是一个全新的对象，不再与原来的对象有任何关联。
```

4. 关于拷贝操作的警告
```
 1、对于非容器类型，如数字，字符，以及其它“原子”类型，没有拷贝一说。产生的都是原对象的引用。
 2、如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。
```

5. 自己使用python的列表del函数一个思维误区
```
不要在迭代中试图删除元素
```

# Python列表函数 #
| 序号 | 方法 | 描述 |
| --- | --- | --- |
| 1 | list.append(obj) | 在列表末尾添加新的对象 | 
| 2 | list.count(obj)  | 统计某个元素在列表中出现的次数 |
| 3	| list.extend(seq) | 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）| 
| 4	| list.index(obj)  | 从列表中找出某个值第一个匹配项的索引位置 | 
| 5	| list.insert(index, obj) | 将对象插入列表| 
| 6	| list.pop(obj=list[-1]) | 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 | 
| 7	| list.remove(obj) | 移除列表中某个值的第一个匹配项（remove 方法用于移除列表中的某个匹配元素，如果有多个匹配，则移除第一个。） | 
| 8	| list.reverse() | 反向列表中元素 | 
| 9	| list.sort([func]) | 对原列表进行排序 | 

# Python列表函数&方法 #
| 序号 | 方法 | 描述 |
| --- | --- | --- |
| 1	| cmp(list1, list2) | 比较两个列表的元素 | 
| 2	| len(list) | 列表元素个数 | 
| 3	| max(list) | 返回列表元素最大值 | 
| 4	| min(list) | 返回列表元素最小值 | 
| 5	| list(seq) | 将元组转换为列表 | 

# Python列表脚本操作符 #
| Python 表达式 | 结果 | 描述 |
| --- | --- | --- |
| len([1, 2, 3]) | 3 | 长度 |
| [1, 2, 3] + [4, 5, 6] | [1, 2, 3, 4, 5, 6] | 组合 |
| ['Hi!'] * 4 | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 重复 |
| 3 in [1, 2, 3]    | True  | 元素是否存在于列表中 |
| for x in [1, 2, 3]: print x, | 1 2 3 | 迭代 |

# Python列表截取 #
L = ['Google', 'Runoob', 'Taobao'] 

| Python 表达式 | 结果 | 描述 |
| --- | --- | --- |
| L[2] | 'Taobao' | 读取列表中第三个元素 |
| L[-2] | 'Runoob' | 读取列表中倒数第二个元素 |
| L[1:] | ['Runoob', 'Taobao'] | 从第二个元素开始截取列表 |

# 多列排序
```
    list_records.sort(
     key = lambda l: (l[0], l[2])
    )
```
