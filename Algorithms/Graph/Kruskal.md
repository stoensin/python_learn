# Kruskal 算法的步骤（克鲁斯克尔算法）：

- [维基百科 - 克鲁斯克尔算法](https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95)
- [Kruskal 最小生成树算法](http://blog.jobbole.com/83939/)

1. 对所有边进行从小到大的排序。
2. 每次选一条边（最小的边），如果如果形成环，就不加入(u,v)中，否则加入。那么加入的(u,v)一定是最佳的。
【如果你非手算不可的话】从小到大地搜索所有边，若不产生环则加入生成树中。Kruskal算法是手动求最小生成树的不错选择。

- prim 算法和kruskal都属于贪婪算法，其中prim算法更接近图的广度优先遍历，取一个点，找能选的权值最小的边；
- 而kruskal则是把边按照从小到大排，如果新加的边的两个端点都被遍历过，就需要检查这两个点是否已经在一个连通通路里面。

# Kruskal 最小生成树算法
Kruskal算法是一种用来查找最小生成树的算法，由Joseph Kruskal在1956年发表。用来解决同样问题的还有Prim算法和Boruvka算法等。

三种算法都是贪心算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。

## 步骤
1. 新建图G，G中拥有原图中相同的节点，但没有边
2. 将原图中所有的边按权值从小到大排序
3. 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中
4. 重复3，直至图G中所有的节点都在同一个连通分量中

## 证明
1. 这样的步骤保证了选取的每条边都是桥，因此图G构成一个树。
2. 为什么这一定是最小生成树呢？关键还是步骤3中对边的选取。算法中总共选取了n-1条边，每条边在选取的当时，都是连接两个不同的连通分量的权值最小的边
3. 要证明这条边一定属于最小生成树，可以用反证法：如果这条边不在最小生成树中，它连接的两个连通分量最终还是要连起来的，通过其他的连法，那么另一种连法与这条边一定构成了环，而环中一定有一条权值大于这条边的边，用这条边将其替换掉，图仍旧保持连通，但总权值减小了。也就是说，如果不选取这条边，最后构成的生成树的总权值一定不会是最小的。





