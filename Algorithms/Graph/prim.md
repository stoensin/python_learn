## Prim算法

> 连通分量是指图的一个子图，子图中任意两个顶点之间都是可达的。最小生成树是连通图的一个连通分量，且所有边的权值和最小。
> 最小生成树中，一个顶点最多与两个顶点邻接；若连通图有n个顶点，则最小生成树中一定有n-1条边。

> Prim算法需要两个线性表来进行辅助：

1. visited:
> 标记已经加入生成树的顶点；（它的功能可以由tree取代）
> 初始状态：生成树根节点为真，其它为0。

2. tree:
> 记录生成树，tree[x]保存顶点x的直接根节点下标，若x为树的根节点则tree[x]为其自身。
> 初始状态：根节点为其自身，其它顶点为NULL。

3. low:
> low[i]记录生成树中顶点与生成树外顶点i所有边中的最小值。
> 初始状态：生成树根节点与其它边之间的权值。

4. Prim算法采用贪心的思想进行设计：
  1). 初始化：将起始点加入生成树中
  2). 在生成树中的顶点与其它顶点之间的边中寻找最小的边加入生成树中（更新visited,tree）;
  3). 搜索新加入顶点与所有生成树外顶点i之间边，若小于原有low[i]则更新low[i];
  4). 重复执行，直至生成树中包含了所有顶点。
  
  
# 问题
无向图最小生成树的Prim算法

# 思路说明

假设点A,B,C,D,E,F，两点之间有连线的，以及它们的距离分别是：(A-B:7);(A-D:5);(B-C:8);(B-D:9);(B-E:7);(C-E:5);(D-E:15);(D-F:6);(E-F:8);(E-G:9);(F-G:11)

关于Prim算法的计算过程，参与维基百科的词条：[普里姆算法](https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95)

将上述点与点关系以及两点之间距离（边长，有的文献中称之为权重）写成矩阵形式（在list中，每两个点及其之间的距离组成一个tuple)

edges = [ ("A", "B", 7), ("A", "D", 5), ("B", "C", 8), ("B", "D", 9), ("B", "E", 7), ("C", "E", 5), ("D", "E", 15), ("D", "F", 6), ("E", "F", 8), ("E", "G", 9), ("F", "G", 11) ]

在下面的解决方法中，要计算出与已经选出的若干个点有相邻关系的点中，相应边长最短的点。
这本质上是排序之后取出最小的，因为这种排序是动态的，如果用sorted或者list.sort()之类的方法对list排序，一则速度慢（python中的sort方法对大数据时不是很快),二则代码也长了。
幸好python提供了一个非常好用的模块：heapq。这个模块是堆排序方法实现排序，并能够随时取出最小值。简化代码，更重要是提升了速度。

就用这个来解决Prim算法问题了。


##### Prim算法与Dijsktra算法非常类似，两者在执行过程上的显著区别在于：Prim算法按边进行搜索，将最小边加入生成树中；
##### Dijsktra算法按顶点进行搜索，选择树外顶点与源点之间最短的边（路径）加入生成树中。

【你如果非手算不可的话】记得在加入新顶点时，标记已加入到生成树中的边以及生成树顶点之间的边。